[{"content":"This post was written in 2022, but I had never posted it by accident. Published in October 2024.\nIntroduction To continue our previous post about the WPICTF 2022 (online, hosted by Worcester Polytechnic Institute Cyber Security Club), we will focus our attention on a pwn challenge. And to change, this time we\u0026rsquo;ll use Ghidra rather than Cutter 😎\nA x64 ELF binary is provided with this challenge, no code is given.\nRecon We explore the terminal user interface (TUI) of the binary, and we find the potential buffer overflow in the B - Name a cat submenu. Let\u0026rsquo;s try to get the offset with gdb-peda:\n1 2 3 4 5 6 7 8 $ pattern create 100 $ r B [paste pattern] A [=\u0026gt; overflow (no RIP erase)] $ pattern_search [=\u0026gt; overflow (RAX erase and RIP pointing to call [RAX])]] As we can see, it will not be that trivial to exploit the vulnerability since RIP is not directly controlled. However, we can see that RIP will point to a call instruction, with the function address stored in RAX, and RAX retrieve this function adress from the value pointed by R12:\nSo, to summarize:\nWe can change what is pointed by R12 with the overflow, This will change the value of RAX, RAX is then used as a function pointer in a call, We can translate in pseudo-code what is happening call *(*(R12)), or simpler:\n1 2 R12 = \u0026amp;(overflow[??]) call *(*R12) = call *overflow[??] Then, we can control the flow and if we change what is pointed by R12 to a pointer to a vulnerable code, we win.\nWithout reversing we already have a lot of information, but to validate our hypothesis we will have to open Ghidra. We quickly find that the code is in C++ (good news) and therefore there is a lot of garbage code. We start to focus on the Cat structure (we can make the hypothesis that it\u0026rsquo;s a class) and find some interesting information using the structure editor of Ghidra:\nAs we can see, the Cat class is composed of a name field of 64 bytes (where the overflow is happening) and a super interesting function pointer vptr_Cat. We know that this a sign of a vtable and confirm that Cat is a class, that surely deal with inheritance.\nAs a reminder of what a vtable is, let\u0026rsquo;s read a bit of Wikipedia:\nIn computer programming, a virtual method table (VMT), virtual function table, virtual call table, dispatch table, vtable, or vftable is a mechanism used in a programming language to support dynamic dispatch (or run-time method binding). Whenever a class defines a virtual function (or method), most compilers add a hidden member variable to the class that points to an array of pointers to (virtual) functions called the virtual method table. These pointers are used at runtime to invoke the appropriate function implementations, because at compile time it may not yet be known if the base function is to be called or a derived one implemented by a class that inherits from the base class.\nTypically, the compiler creates a separate virtual method table for each class. When an object is created, a pointer to this table, called the virtual table pointer, vpointer or VPTR, is added as a hidden member of this object. As such, the compiler must also generate \u0026ldquo;hidden\u0026rdquo; code in the constructors of each class to initialize a new object\u0026rsquo;s virtual table pointer to the address of its class\u0026rsquo;s virtual method table.\nSince everything is better explained with a diagram, here is one:\nIf you want to delve deeper into the subject, a good reference is available here: SMASHING C++ VPTRS. We can see the vtable in gdb:\nSo, we know via gdb that we need to deal with a function pointer to exploit the buffer overflow, and we just saw that the overflowable Cat class contains a vptr. We are close to victory, now we just have to make a choice to exploit the situation:\nPlace our own vtable (pointer) in memory and make R12 point to it, Use the current vtable, but call a vulnerable function. The second option is the simplest, but we need to dig a bit more to make a definitive choice. So let\u0026rsquo;s check the binary\u0026rsquo;s protections:\n1 2 3 4 5 CANARY : ENABLED FORTIFY : disabled NX : disabled PIE : disabled RELRO : Partial That\u0026rsquo;s good, we can use both techniques without issue (we don\u0026rsquo;t have to deal with any canaries for this buffer overflow). Now let\u0026rsquo;s find the offset to control R12:\nThe offset is 64 (name) + 8 (padding) to control what is pointed by R12 and therefore RAX. We can now search for a vulnerable function in Ghidra by searching for a reference to flag.txt (CTF classic):\nVulnerable function found, in place of the pet function of the HackerCat structure. After a bit more digging in Ghidra, we know that HackerCat inherit from the Cat class, and that the function pet is a virtual function. Therefore, to call this function the binary will use the vtable of the concerned object.\nTo call a virtual function at runtime, the binary will use this format: (*(vtable_addr) + function_offset)(). After a quick look in Ghidra we can find that the pet virtual function is not the first in the vtable (function_offset is not 0), and therefore a call to this function will have this form:\n1 2 3 vptr = \u0026amp;vtable pet_fn_offset = ?? call [*(vptr + pet_fn_offset)] However, we found that a virtual function is called when doing A - List all cats, and it\u0026rsquo;s the first in the vtable (function_offset is 0). Therefore we end with this layout:\n1 2 vptr = \u0026amp;vtable call [*vptr] So we have again two possibilities:\nWe can make an exploit using C - Pet a cat that will call the pet virtual function. This implies using the vtable of the HackerCat class to be able to call the HackerCat::pet win function. We can use A - List all cats that call another virtual function. This implies replacing a virtual function address with HackerCat::pet. In a diagram this translates to (we find at the top the initial situations, and at the bottom the corresponding exploitation path):\nBoth options are good, but let\u0026rsquo;s take the second option that is simpler to debug. Let\u0026rsquo;s retrieve the vtable address of HackerCat and the address of the pointer to HackerCat::pet in the same table:\nNow, our plan is complete and, since there are no particular protections, we can test everything locally and find the right addresses, then we will just have to replay the same sequence on the online address. The plan is therefore as follows:\nWe know that we can overwrite the address of the vtable of Cat objects. We know that pointers to (virtual) functions in this vtable are called for A - List all cats and C - Pet a cat TUI commands. We know that the function which will give us the flag is HackerCat::pet. We know that if we replace the vptr pointer of a Cat object with the HackerCat::pet pointer of the vtable we win. So we just have to send an input in the menu \u0026ldquo;B - Name a cat\u0026rdquo; which contains the overflowable input with 72 bytes of garbage and then the address of the pointer to the function HackerCat::pet, which can be found in the vtable of HackerCat via Ghidra. This gives us the following exploit (that is very simple, but we like overthinking here):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from ctypes import LittleEndianStructure from gc import garbage from pwn import * context.arch = \u0026#39;amd64\u0026#39; context.endian = \u0026#39;little\u0026#39; r = remote(\u0026#39;calicovision.wpi-ctf-2022-codelab.kctf.cloud\u0026#39;, 1337) # since we can erase the vtable address, the form of the call will be (*(vtable))() # so we need to place the address of a pointer to the right function # to do that, we can use the vtable of the already existing object we want to use (HackerCat) # Trigger the BOF garbage = b\u0026#39;A\u0026#39; * 72 # Here we place the address of the vtable pointer to HackerCat::pet =\u0026gt; 0x5b0078. function_address = p64(0x5b0078) exploit = garbage + function_address print(r.recvlines(13)) # B - rename cat r.sendline(\u0026#39;B\u0026#39;) # New name = exploit r.sendline(exploit) # A - list cats r.sendline(b\u0026#39;A\u0026#39;) print(r.recvall(timeout=2)) r.close() And we get the flag: WPI{c0rrup73d_c475_cr3473_ch405}.\nIn the end, this was very simple, but allowed us to manipulate vtables and many tools.\n","date":"2022-11-05T10:00:00+02:00","image":"https://dorianb.net/blog/p/wpictf-2022-pwn-calicovision/gdb_overflow_hu13455590952101266989.png","permalink":"https://dorianb.net/blog/p/wpictf-2022-pwn-calicovision/","title":"WPICTF 2022 - PWN - Calicovision"},{"content":"This post was written in 2022, but I had never posted it by accident. Published in October 2024.\nIntroduction To do a small warming up before the Purple Pill Challenge CTF, we participated in the WPICTF 2022 CTF (online, hosted by Worcester Polytechnic Institute Cyber Security Club). Since the solved reverse challenges were a bit simple, you\u0026rsquo;ll find in this post a collection of some of them rather than a single one (opposed to the tradition).\nTaylor\u0026rsquo;s Serious Data This was a (very) simple one. We were given an x64 ELF binary with a text file \u0026ldquo;songLyrics.txt\u0026rdquo; that seems encrypted. After opening the binary in Cutter, we can find the encryption routine in the main function:\nAs we can see in the decompiler window, the binary takes two arguments:\nAn initial file path, A file path to store the decrypted version of the first file. Then, the function load a file from disk (for sure the songLyrics.txt file), and read it. After that, it retrieves the content size of the file, and start the decryption loop. When dealing with this kind of loop, I prefer to deal with the assembly directly rather the decompiler. After a simple analysis, I found that the decryption loop was:\n1 2 for character c in file: output = c * 7 + 34 As we can see, the Ghidra decompiler was right (this time 😁), and we can write a simple python script that will decrypt the given file for us:\n1 2 3 4 5 6 7 8 9 10 11 12 file = open(\u0026#39;./songLyrics.txt\u0026#39;, \u0026#39;r\u0026#39;) content = file.read() content = content.split() for char in content: c = int(char) a = int((c - 0x22) / 0xd) print(chr(a), end=\u0026#39;\u0026#39;, sep=\u0026#39;\u0026#39;) file.close() We then obtain the decrypted version of our file (and the filename was right, it\u0026rsquo;s a song lyric):\n1 2 3 4 5 6 7 ... But I got smarter, I got harder in the nick of time [...] Honey, WPI{TaYl0rs_v3rS1oN} I rose up from the dead, I do it all the time I got a list of names, and yours is in red, underlined [...] ... And we get the flag WPI{TaYl0rs_v3rS1oN}. This was a very simple warmup, no tricky things here.\nxf1ltr80r Let\u0026rsquo;s investigate a second challenge. We start with a x64 ELF binary, and since I liked using Cutter on the previous challenge, I\u0026rsquo;ll continue with it. After opening the binary, we easily find the function containing \u0026ldquo;data to exfiltrate\u0026rdquo;:\nThe padding (==) at the end of the many blobs of data seem to indicate a base64 encoded string. Let\u0026rsquo;s retrieve the full encoded string:\n1 V1BJezN4dHIzbTNseV9uI3JkeV8xMzM3NXAzNGt9Cg== We can now use Cyberchef to perform the operation:\nAnd another flag: WPI{3xtr3m3ly_n#rdy_13375p34k}. Very trivial.\nNeedToCough This is the last \u0026ldquo;easy\u0026rdquo; challenge I did and it was, in my opinion, the best one (still trivial, but the journey was nice and somehow realistic). We start the challenge with a pcap file that contains multiple HTTP requests and an encrypted file that was a jpg image. After analyzing some frames, I found that these requests contained a file. Therefore, I exported it using Wireshark:\nI obtained (again) a nice x64 ELF binary file. Since it worked well for the previous challenges, I stayed with Cutter here, and analyzed the code. After a high level review on the disassembly, I found that the majority of the code was garbage about a notice drop (ransomware-like), so I focused on the encryption loop. I found four interesting functions:\nOne that converts an input to hexadecimal code, A second that generates a hexadecimal table (for the permutation), An encryption function that uses a permutation table (over hexadecimal), And a last one that generates the permutation table. The part that generates the permutation table is at the beginning of a function that also deals with the notice part (useless here):\nAs I said before, I prefer to look at the assembly rather than the decompiler code (especially when you see how little code is present). I extracted this pseudo-code used to generate the permutation table:\n1 2 for i in [0,16]: output[i] = key1[i % 0x17] ^ key2[i] I then successfully extracted the two keys key1 and key2 from the binary:\n1 2 3 # Extracted key1 key1_first = \u0026#39;6874202e2e2e6159\u0026#39; key1_second = \u0026#39;6157207369207369\u0026#39; Since we were in little endian, we needed to convert it before concatenation:\n1 2 3 4 5 6 # Convert it since we are in little endian key1_first = bytearray.fromhex(key1_first) key1_first.reverse() key1_second = bytearray.fromhex(key1_second) key1_second.reverse() key1 = key1_first + key1_second We do the same with the key2:\n1 2 3 4 5 6 7 8 9 10 # Extracted key2 key2_first = \u0026#39;5d46661f181e226e\u0026#39; key2_second = \u0026#39;2316644050143651\u0026#39; # Convert it since we are in little endian key2_first = bytearray.fromhex(key2_first) key2_first.reverse() key2_second = bytearray.fromhex(key2_second) key2_second.reverse() key2 = key2_first + key2_second We can now recreate the algorithm that generates the permutation table:\n1 2 3 4 # Generate the permutation table from the two keys permutation_table = [None] * 16 for i in range(0x10): permutation_table[i] = chr(key1[i % 0x17] ^ key2[i]) Then, we can continue with another easy part, by analyzing the hexadecimal table generation code:\nWe can translate this assembly function to python:\n1 2 3 4 5 6 7 8 9 table = [None] * (9 + 7) # First loop, for the first 9 characters for i in range(9, -1, -1): table[9 - i] = chr(ord(\u0026#39;9\u0026#39;) - i) # Second loop, for the 7 remaining characters for i in range(1, 7, 1): table[9 + i] = chr(i + ord(\u0026#39;@\u0026#39;)) As we can see, it\u0026rsquo;s a complicated code for a simple task, in the end it just generate this string:\n1 0123456789ABCDEF We can now analyze the main encryption loop:\nAs we can see in Cutter, the permutation loop is very simple, and we can reconstruct it in python:\n1 2 3 4 for i in range(0xbeca): for j in range(0x10): if initial_image[i] == table[j]: encrypted_image[i] = permutation_table[j] We then revert the operation and get this python code:\n1 2 3 4 for i in range(0xbeca): for j in range(0x10): if encrypted_image[i] == permutation_table[j]: initial_image[i] = table[j] Since our image already contains the ASCII representation of the file content in hexadecimal, we can retrieve the initial image with this python code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 # Extracted key1 key1_first = \u0026#39;6874202e2e2e6159\u0026#39; key1_second = \u0026#39;6157207369207369\u0026#39; # Extracted key2 key2_first = \u0026#39;5d46661f181e226e\u0026#39; key2_second = \u0026#39;2316644050143651\u0026#39; # Convert it since we are in little endian key1_first = bytearray.fromhex(key1_first) key1_first.reverse() key1_second = bytearray.fromhex(key1_second) key1_second.reverse() key1 = key1_first + key1_second # Convert it since we are in little endian key2_first = bytearray.fromhex(key2_first) key2_first.reverse() key2_second = bytearray.fromhex(key2_second) key2_second.reverse() key2 = key2_first + key2_second # Generate the permutation table from the two keys permutation_table = [None] * 16 for i in range(0x10): permutation_table[i] = chr(key1[i % 0x17] ^ key2[i]) table = [None] * (9 + 7) # First loop, for the first 9 characters for i in range(9, -1, -1): table[9 - i] = chr(ord(\u0026#39;9\u0026#39;) - i) # Second loop, for the 7 remaining characters for i in range(1, 7, 1): table[9 + i] = chr(i + ord(\u0026#39;@\u0026#39;)) # Comp = out = res (what we need to retrieve) initial_image = [None] * 0xbeca # Out = pvVar2 = encrypted (what we know) file = open(\u0026#39;./flag.cough\u0026#39;, \u0026#39;r\u0026#39;) encrypted_image = file.read() file.close() # Logic for i in range(0xbeca): for j in range(0x10): if encrypted_image[i] == permutation_table[j]: initial_image[i] = table[j] # Dump flag f = open(\u0026#39;./flag.jpg\u0026#39;, \u0026#39;wb\u0026#39;) f.write(flag) f.close() A tip I used to debug this script was checking that we get the magic number of JPEG files for the first bytes. This can also be used to brute force the permutation table (if you don\u0026rsquo;t like reverse engineering 😉).\nAfter running the script on the provided file (containing the encrypted image to retrieve), I obtained the initial image:\nAnd the flag was WPI{cybercriminals != pentesters}!\nThanks for this well-made challenge, that were not difficult but well constructed (from Wireshark to reverse).\nConclusion Those reverse challenges were fun to complete even if a bit too simple. They were a good training for our big event (the Purple Pill Challenge CTF) that were 5 days after this one. Maybe it can help someone getting into reverse 🤷‍♂️\n","date":"2022-10-04T18:35:19+02:00","image":"https://dorianb.net/blog/p/wpictf-2022-reverse-warmup/1_cutter_hu571265526667602783.png","permalink":"https://dorianb.net/blog/p/wpictf-2022-reverse-warmup/","title":"WPICTF 2022 - Reverse - Warmup"}]